# -*- coding: utf-8 -*-
"""algo_num_version2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BtQVxZ-aYhRITqrMwRlKUgu60eqZDK_7
"""

import numpy as np
from scipy.linalg import svd, qr
import matplotlib.pyplot as plt
import time
import random
from collections import defaultdict

class DocumentSearchSystem:
    def __init__(self, documents=None):
        if documents:
            self.load_documents(documents)

    def load_documents(self, documents):
        """Question 4(a): Charge les documents et construit la matrice D"""
        # Question 4(b): Extraire la liste des mots-clés triés et sans doublons
        self.terms = sorted(list(set(term for doc in documents for term in doc)))
        self.doc_ids = list(range(len(documents)))

        # Construire la matrice termes-documents (binaire)
        self.D = np.zeros((len(self.terms), len(documents)))
        for j, doc in enumerate(documents):
            for term in doc:
                i = self.terms.index(term)
                self.D[i, j] = 1

    def query_to_vector(self, query_terms):
        """Convertit une requête en vecteur"""
        q = np.zeros(len(self.terms))
        for term in query_terms:
            if term in self.terms:
                i = self.terms.index(term)
                q[i] = 1
        return q

    # Question 1(a): Méthode sans SVD
    def basic_score(self, q):
        """Calcul des scores sans SVD"""
        scores = []
        q_norm = np.linalg.norm(q)

        for j in range(self.D.shape[1]):
            d_j = self.D[:, j]
            d_norm = np.linalg.norm(d_j)
            score = np.dot(q, d_j) / (q_norm * d_norm) if q_norm * d_norm != 0 else 0
            scores.append((self.doc_ids[j], score))

        return sorted(scores, key=lambda x: x[1], reverse=True)

    # Question 1(b): Méthode avec SVD directe
    def svd_score(self, q, k):
        """Calcul des scores avec SVD directe"""
        U, s, Vt = svd(self.D, full_matrices=False)
        Uk = U[:, :k]
        sk = s[:k]
        Vtk = Vt[:k, :]

        scores = []
        q_tilde = np.dot(Uk.T, q)

        for j in range(self.D.shape[1]):
            v_j = Vtk[:, j]
            numerator = np.dot(q_tilde, sk * v_j)
            denominator = np.linalg.norm(q_tilde) * np.linalg.norm(sk * v_j)
            score = numerator / denominator if denominator != 0 else 0
            scores.append((self.doc_ids[j], score))

        return sorted(scores, key=lambda x: x[1], reverse=True)

    # Question 1(c): Méthode avec bidiagonalisation + QR
    def bidiag_qr_score(self, q, k, max_iter=100, tol=1e-6):
        """Calcul des scores avec bidiagonalisation + QR"""
        m, n = self.D.shape

        # Étape 1: Bidiagonalisation
        B = np.zeros((m, n))
        U = np.eye(m)
        V = np.eye(n)

        # Algorithme de Golub-Kahan
        for i in range(n):
            # Householder pour la colonne i
            x = self.D[i:, i]
            if np.linalg.norm(x) == 0:
                continue
            e = np.zeros_like(x)
            e[0] = 1
            u = x - np.linalg.norm(x) * e
            u = u / np.linalg.norm(u) if np.linalg.norm(u) > 0 else u
            self.D[i:, i:] = self.D[i:, i:] - 2 * np.outer(u, np.dot(u.T, self.D[i:, i:]))
            U[:, i:] = U[:, i:] - 2 * np.outer(np.dot(U[:, i:], u), u.T)

            if i < n-2:
                # Householder pour la ligne i
                x = self.D[i, i+1:]
                if np.linalg.norm(x) == 0:
                    continue
                e = np.zeros_like(x)
                e[0] = 1
                v = x - np.linalg.norm(x) * e
                v = v / np.linalg.norm(v) if np.linalg.norm(v) > 0 else v
                self.D[i:, i+1:] = self.D[i:, i+1:] - 2 * np.outer(np.dot(self.D[i:, i+1:], v), v.T)
                V.T[:, i+1:] = V.T[:, i+1:] - 2 * np.outer(np.dot(V.T[:, i+1:], v), v.T)

        B = self.D.copy()

        # Étape 2: SVD de la matrice bidiagonale
        sigma, U_bidiag, V_bidiag = self._bidiag_svd(B[:n, :], max_iter, tol)

        # Reconstruction des matrices de la SVD complète
        U_svd = np.dot(U[:, :n], U_bidiag)
        V_svd = np.dot(V, V_bidiag)

        # Calcul des scores
        Uk = U_svd[:, :k]
        sk = sigma[:k]
        Vk = V_svd[:, :k]

        scores = []
        q_tilde = np.dot(Uk.T, q)

        for j in range(n):
            v_j = Vk[j, :]
            numerator = np.dot(q_tilde, sk * v_j)
            denominator = np.linalg.norm(q_tilde) * np.linalg.norm(sk * v_j)
            score = numerator / denominator if denominator != 0 else 0
            scores.append((self.doc_ids[j], score))

        return sorted(scores, key=lambda x: x[1], reverse=True)

    def _bidiag_svd(self, B, max_iter, tol):
        """Calcul SVD d'une matrice bidiagonale via QR iterations"""
        n = B.shape[0]
        U = np.eye(n)
        V = np.eye(n)
        B_k = B.copy()

        for _ in range(max_iter):
            # QR de B_k^T
            Q1, R1 = qr(B_k.T)
            # QR de R1^T
            Q2, R2 = qr(R1.T)

            # Mise à jour
            U = np.dot(U, Q2)
            V = np.dot(V, Q1.T)
            B_k = R2

            # Test de convergence
            if np.sum(np.abs(np.diag(B_k, 1))) < tol:
                break

        return np.diag(B_k), U, V

    def reconstruction_error(self, k):
        """Question 2(b): Calcule l'erreur de reconstruction"""
        U, s, Vt = svd(self.D, full_matrices=False)
        D_k = np.dot(U[:, :k], np.dot(np.diag(s[:k]), Vt[:k, :]))
        return np.linalg.norm(self.D - D_k, 2)

def load_documents_from_file(filename):
    """Charge les documents depuis un fichier pour la question 4"""
    documents = []
    with open(filename, 'r', encoding='utf-8') as f:
        for line in f:
            terms = line.strip().lower().split()
            documents.append(terms)
    return documents

def example1():
    """Question 2: Exemple 1 du projet"""
    documents = [
        ["matrice", "algèbre", "linéaire"],
        ["algèbre", "groupe", "anneau"],
        ["matrice", "déterminant"],
        ["espace", "vectoriel"],
        ["algèbre", "linéaire", "application"],
        ["matrice", "diagonalisation"]
    ]

    system = DocumentSearchSystem(documents)
    q1 = ["matrice", "algèbre"]

    print("=== Exemple 1 ===")
    print("Requête:", q1)

    # Question 2(a): Classement des documents
    print("\n(a) Scores sans SVD:")
    scores = system.basic_score(system.query_to_vector(q1))
    for doc_id, score in scores:
        print(f"Document {doc_id+1}: {score:.4f}")

    print("\n(b) Scores avec SVD directe (k=2):")
    scores = system.svd_score(system.query_to_vector(q1), 2)
    for doc_id, score in scores:
        print(f"Document {doc_id+1}: {score:.4f}")

    print("\n(c) Scores avec bidiagonalisation + QR (k=2):")
    scores = system.bidiag_qr_score(system.query_to_vector(q1), 2)
    for doc_id, score in scores:
        print(f"Document {doc_id+1}: {score:.4f}")

    # Question 2(b): Erreur de reconstruction
    print("\nErreur de reconstruction en fonction de k:")
    max_k = min(system.D.shape)
    errors = [system.reconstruction_error(k) for k in range(1, max_k+1)]
    for k, err in enumerate(errors, 1):
        print(f"k={k}: {err:.4f}")

    plt.figure()
    plt.plot(range(1, max_k+1), errors)
    plt.xlabel('Rang k')
    plt.ylabel('Erreur de reconstruction ||D - D_k||_2')
    plt.title('Exemple 1 - Erreur de reconstruction')
    plt.show()

def example3():
    """Question 2: Exemple 3 du projet (documents économie/géologie)"""
    documents = [
        ["chômage", "impôts", "dépression", "commerce"],  # Doc 1 (éco)
        ["économie", "marché", "commerce"],               # Doc 2 (éco)
        ["commerce", "marché", "production"],             # Doc 3 (éco)
        ["dépression", "liquidation", "emploi", "redressement"],  # Doc 4 (éco)
        ["indemnisation", "chômage", "liquidation"],      # Doc 5 (éco)
        ["commerce", "marché", "prix", "emploi"],         # Doc 6 (éco)
        ["bénéfices", "indemnisation", "chômage"],        # Doc 7 (éco)
        ["bassin", "faille", "dérive"],                   # Doc 8 (géol)
        ["dépression", "faille"],                         # Doc 9 (géol)
        ["bassin", "drainage", "vallée"],                 # Doc 10 (géol)
        ["dépression", "drainage", "érosion"],            # Doc 11 (géol)
        ["bassin", "drainage", "volcan"]                  # Doc 12 (géol)
    ]

    system = DocumentSearchSystem(documents)
    q2 = ["dépression", "croissance"]
    q3 = ["bassin", "fiscalité"]

    print("\n=== Exemple 3 ===")

    # Question 2(a) et 2(c): Test avec différentes requêtes
    for q, q_name in [(q2, "q2 (dépression, croissance)"), (q3, "q3 (bassin, fiscalité)")]:
        print(f"\nRequête: {q_name}")

        print("\nScores sans SVD:")
        scores = system.basic_score(system.query_to_vector(q))
        for doc_id, score in scores:
            print(f"Document {doc_id+1}: {score:.4f} - {'Économie' if doc_id < 7 else 'Géologie'}")

        print("\nScores avec SVD (k=2):")
        scores = system.svd_score(system.query_to_vector(q), 2)
        for doc_id, score in scores:
            print(f"Document {doc_id+1}: {score:.4f} - {'Économie' if doc_id < 7 else 'Géologie'}")

        # Question 2(c): Comparaison avec seuil
        print("\nDocuments avec score > 0.5 (SVD k=2):")
        high_scores = [doc for doc in scores if doc[1] > 0.5]
        for doc_id, score in high_scores:
            print(f"Document {doc_id+1}: {score:.4f} - {'Économie' if doc_id < 7 else 'Géologie'}")

    # Question 2(b): Erreur de reconstruction
    print("\nErreur de reconstruction en fonction de k:")
    max_k = min(system.D.shape)
    errors = [system.reconstruction_error(k) for k in range(1, max_k+1)]
    for k, err in enumerate(errors, 1):
        print(f"k={k}: {err:.4f}")

    plt.figure()
    plt.plot(range(1, max_k+1), errors)
    plt.xlabel('Rang k')
    plt.ylabel('Erreur de reconstruction ||D - D_k||_2')
    plt.title('Exemple 3 - Erreur de reconstruction')
    plt.show()

def performance_test():
    """Question 3: Test de performance pour différentes tailles de matrices"""
    methods = ['basic', 'svd', 'bidiag_qr']
    k = 10  # Rang fixé pour les tests

    # Tailles à tester
    Nd_values = list(range(5, 200, 5))  # Réduit pour les tests
    times = {method: [] for method in methods}

    for Nd in Nd_values:
        Nt = 3 * Nd  # Comme spécifié

        # Générer une matrice aléatoire
        D = np.random.randint(0, 2, size=(Nt, Nd))
        q = np.random.randint(0, 2, size=(Nt,))

        # Créer un système temporaire
        temp_system = DocumentSearchSystem()
        temp_system.D = D
        temp_system.terms = list(range(Nt))
        temp_system.doc_ids = list(range(Nd))

        # Mesurer le temps pour chaque méthode
        for method in methods:
            start_time = time.time()

            if method == 'basic':
                temp_system.basic_score(q)
            elif method == 'svd':
                temp_system.svd_score(q, k)
            elif method == 'bidiag_qr':
                temp_system.bidiag_qr_score(q, k)

            times[method].append(time.time() - start_time)

        print(f"Nd={Nd} terminé")

    # Tracer les résultats
    plt.figure(figsize=(10, 6))
    for method in methods:
        plt.plot(Nd_values, times[method], label=method)

    plt.xlabel('Nombre de documents (Nd)')
    plt.ylabel('Temps d\'exécution (s)')
    plt.title('Question 3 - Temps d\'exécution en fonction de la taille')
    plt.legend()
    plt.grid()
    plt.show()

def process_documents_file(filename):
    """Question 4 et 5: Traitement du fichier de documents"""
    try:
        documents = load_documents_from_file(filename)
        system = DocumentSearchSystem(documents)

        print(f"\nQuestion 4: Base chargée - {len(documents)} documents, {len(system.terms)} termes")

        # Question 5: Requête aléatoire
        random_query = random.sample(system.terms, min(2, len(system.terms)))
        print("\nQuestion 5: Requête aléatoire:", random_query)

        # Calculer les scores
        q_vec = system.query_to_vector(random_query)

        print("\nScores sans SVD:")
        scores = system.basic_score(q_vec)
        for doc_id, score in scores[:5]:  # Afficher les 5 premiers
            print(f"Document {doc_id+1}: {score:.4f}")

        print("\nScores avec SVD (k=5):")
        scores = system.svd_score(q_vec, 5)
        for doc_id, score in scores[:5]:
            print(f"Document {doc_id+1}: {score:.4f}")

        print("\nScores avec bidiagonalisation + QR (k=5):")
        scores = system.bidiag_qr_score(q_vec, 5)
        for doc_id, score in scores[:5]:
            print(f"Document {doc_id+1}: {score:.4f}")

        # Erreur de reconstruction
        max_k = min(20, min(system.D.shape))  # Limiter à 20 pour le graphique
        errors = [system.reconstruction_error(k) for k in range(1, max_k+1)]

        plt.figure()
        plt.plot(range(1, max_k+1), errors)
        plt.xlabel('Rang k')
        plt.ylabel('Erreur de reconstruction ||D - D_k||_2')
        plt.title('Question 4 - Erreur de reconstruction')
        plt.show()

    except FileNotFoundError:
        print(f"Erreur: Le fichier {filename} n'a pas été trouvé.")

def main():
    """Fonction principale"""
    print("=== Projet de Gestion de Bases de Données Bibliographiques ===")

    # Question 2
    print("\n=== Question 2 ===")
    example1()
    example3()

    # Question 3
    print("\n=== Question 3 ===")
    performance_test()

    # Questions 4 et 5
    print("\n=== Questions 4 et 5 ===")
    process_documents_file("documents.txt")

if __name__ == "__main__":
    main()