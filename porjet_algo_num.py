# -*- coding: utf-8 -*-
"""Porjet_algo_num.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DHpp80QZPZnauCqM0f7PMc_bvFzHGEMZ
"""

import numpy as np

def qr_decomposition(A):
    """
    Décomposition QR d'une matrice carrée par Gram-Schmidt modifié
    """
    n = A.shape[0]
    Q = np.zeros((n, n))
    R = np.zeros((n, n))

    for j in range(n):
        v = A[:, j]
        for i in range(j):
            R[i, j] = np.dot(Q[:, i], A[:, j])
            v = v - R[i, j] * Q[:, i]
        R[j, j] = np.linalg.norm(v)
        Q[:, j] = v / R[j, j]

    return Q, R

def givens_rotation(a, b):
    """
    Calcule la matrice de rotation de Givens pour annuler b
    """
    if b == 0:
        c, s = 1, 0
    else:
        if abs(b) > abs(a):
            tau = -a / b
            s = 1 / np.sqrt(1 + tau**2)
            c = s * tau
        else:
            tau = -b / a
            c = 1 / np.sqrt(1 + tau**2)
            s = c * tau
    return c, s

def qr_decomposition_bidiagonal(B):
    """
    Décomposition QR optimisée pour matrices bidiagonales inférieures
    """
    n = B.shape[0]
    Q = np.eye(n)
    R = B.copy()

    for i in range(n-1):
        c, s = givens_rotation(R[i, i], R[i+1, i])
        G = np.eye(n)
        G[i, i] = c
        G[i+1, i+1] = c
        G[i, i+1] = s
        G[i+1, i] = -s

        R = G.T @ R
        Q = Q @ G

    return Q, R

import numpy as np

def qr_decomposition_bidiagonal(B):
    """
    Décomposition QR optimisée pour matrices bidiagonales (version corrigée)
    """
    m, n = B.shape
    Q = np.eye(m)
    R = B.copy()

    min_dim = min(m, n)

    for i in range(min_dim - 1):
        if i + 1 >= m:
            break

        c, s = givens_rotation(R[i, i], R[i+1, i])
        G = np.eye(m)
        G[i, i] = c
        G[i+1, i+1] = c
        G[i, i+1] = s
        G[i+1, i] = -s

        R = G.T @ R
        Q = Q @ G

    return Q, R

def svd_bidiagonal(B, max_iter=1000, tol=1e-8):
    """
    Calcul de la DVS d'une matrice bidiagonale (version corrigée)
    """
    m, n = B.shape
    U = np.eye(m)
    V = np.eye(n)
    B_curr = B.copy()

    for _ in range(max_iter):
        # QR de B^T
        Q, R = qr_decomposition_bidiagonal(B_curr.T)
        # QR de R^T
        Q_hat, B_new = qr_decomposition_bidiagonal(R.T)

        U = U @ Q_hat
        V = V @ Q.T

        # Vérifier la convergence (seulement les éléments super-diagonaux)
        off_diag = 0
        min_dim = min(m, n)
        for i in range(min_dim - 1):
            off_diag += abs(B_new[i, i+1])

        if off_diag < tol:
            break

        B_curr = B_new

    # Extraire les valeurs singulières (diagonale principale)
    S = np.zeros(min(m, n))
    for i in range(min(m, n)):
        S[i] = abs(B_curr[i, i])

    # Trier par ordre décroissant
    idx = np.argsort(S)[::-1]
    S = S[idx]
    U = U[:, idx]
    V = V[:, idx]

    return U, S, V.T

def query_processing(D, query_terms, terms, k=None, threshold=0.8):
    """
    Traitement d'une requête avec réduction de rang optionnelle (version corrigée)
    """
    # Construire le vecteur requête
    q = np.zeros(len(terms))
    for term in query_terms:
        if term in terms:
            q[terms.index(term)] = 1

    if k is None:
        # Méthode standard sans réduction de rang
        scores = [cosine_similarity(q, D[:, j]) for j in range(D.shape[1])]
    else:
        try:
            # Avec réduction de rang
            U, S, Vt = svd(D)
            k = min(k, len(S))  # S'assurer que k ne dépasse pas le nombre de valeurs singulières

            Uk = U[:, :k]
            Sk = np.diag(S[:k])
            Vk = Vt[:k, :].T

            # Calcul des scores selon la formule du texte
            UkTq = Uk.T @ q
            SkVkT = Sk @ Vk.T
            scores = []
            for j in range(D.shape[1]):
                numerator = np.dot(UkTq, SkVkT[:, j])
                denominator = np.linalg.norm(UkTq) * np.linalg.norm(SkVkT[:, j])
                if denominator == 0:
                    scores.append(0)
                else:
                    scores.append(numerator / denominator)
        except np.linalg.LinAlgError:
            # En cas d'échec de la DVS, revenir à la méthode standard
            scores = [cosine_similarity(q, D[:, j]) for j in range(D.shape[1])]

    # Filtrer et trier les résultats
    ranked_docs = sorted([(score, j) for j, score in enumerate(scores)], reverse=True)
    filtered_docs = [(score, j) for score, j in ranked_docs if score >= threshold]

    return filtered_docs

def svd_bidiagonal(B, max_iter=1000, tol=1e-8):
    """
    Calcul de la DVS d'une matrice bidiagonale (étape 2)
    """
    n = B.shape[0]
    U = np.eye(n)
    V = np.eye(n)

    for _ in range(max_iter):
        # QR de B^T
        Q, R = qr_decomposition_bidiagonal(B.T)
        # QR de R^T
        Q_hat, B_new = qr_decomposition_bidiagonal(R.T)

        U = U @ Q_hat
        V = V @ Q.T

        # Vérifier la convergence
        off_diag = np.sum(np.abs(B_new - np.diag(np.diag(B_new))))
        if off_diag < tol:
            break

        B = B_new

    # Les valeurs singulières sont sur la diagonale de B
    S = np.diag(B)
    # Trier par ordre décroissant
    idx = np.argsort(S)[::-1]
    S = S[idx]
    U = U[:, idx]
    V = V[:, idx]

    return U, S, V.T

def svd(A, max_iter=1000, tol=1e-8):
    """
    DVS complète d'une matrice A
    """
    # Étape 1: Bidiagonalisation
    U, B, V = bidiagonalization(A)

    # Étape 2: DVS de la matrice bidiagonale
    U_b, S, V_b = svd_bidiagonal(B, max_iter, tol)

    # Combiner les résultats
    U_final = U @ U_b
    V_final = V @ V_b

    return U_final, S, V_final

def build_term_document_matrix(documents, terms):
    """
    Construit la matrice termes-documents
    documents: liste de listes de termes pour chaque document
    terms: liste de tous les termes possibles
    """
    Nt = len(terms)
    Nd = len(documents)
    D = np.zeros((Nt, Nd))

    term_to_index = {term: i for i, term in enumerate(terms)}

    for j, doc in enumerate(documents):
        for term in doc:
            if term in term_to_index:
                i = term_to_index[term]
                D[i, j] = 1

    return D

def cosine_similarity(q, d):
    """Calcul du cosinus entre deux vecteurs"""
    dot = np.dot(q, d)
    norm_q = np.linalg.norm(q)
    norm_d = np.linalg.norm(d)
    if norm_q == 0 or norm_d == 0:
        return 0
    return dot / (norm_q * norm_d)

def query_processing(D, query_terms, terms, k=None, threshold=0.8):
    """
    Traitement d'une requête avec réduction de rang optionnelle
    """
    # Construire le vecteur requête
    q = np.zeros(len(terms))
    for term in query_terms:
        if term in terms:
            q[terms.index(term)] = 1

    if k is None:
        # Méthode standard sans réduction de rang
        scores = [cosine_similarity(q, D[:, j]) for j in range(D.shape[1])]
    else:
        # Avec réduction de rang
        U, S, Vt = svd(D)
        Uk = U[:, :k]
        Sk = np.diag(S[:k])
        Vk = Vt[:k, :].T

        # Calcul des scores selon la formule du texte
        UkTq = Uk.T @ q
        SkVkT = Sk @ Vk.T
        scores = []
        for j in range(D.shape[1]):
            numerator = np.dot(UkTq, SkVkT[:, j])
            denominator = np.linalg.norm(UkTq) * np.linalg.norm(SkVkT[:, j])
            if denominator == 0:
                scores.append(0)
            else:
                scores.append(numerator / denominator)

    # Filtrer et trier les résultats
    ranked_docs = sorted([(score, j) for j, score in enumerate(scores)], reverse=True)
    filtered_docs = [(score, j) for score, j in ranked_docs if score >= threshold]

    return filtered_docs

# Données de l'exemple
economic_docs = [
    ["chômage", "impôts", "dépression", "commerce"],
    ["économie", "marché", "commerce"],
    ["commerce", "marché", "production"],
    ["dépression", "liquidation", "emploi", "redressement"],
    ["indemnisation", "chômage", "liquidation"],
    ["commerce", "marché", "prix", "emploi"],
    ["bénéfices", "indemnisation", "chômage"]
]

geology_docs = [
    ["bassin", "faille", "dérive"],
    ["dépression", "faille"],
    ["bassin", "drainage", "vallée"],
    ["dépression", "drainage", "érosion"],
    ["bassin", "drainage", "volcan"]
]

all_docs = economic_docs + geology_docs

# Tous les termes uniques
all_terms = sorted(list(set(term for doc in all_docs for term in doc)))

# Construire la matrice termes-documents
D = build_term_document_matrix(all_docs, all_terms)

# Exemple de requêtes
queries = [
    ["dépression", "économie"],
    ["dépression", "commerce"],
    ["emploi"]
]

# Traiter les requêtes avec et sans réduction de rang
print("=== Sans réduction de rang ===")
for q in queries:
    results = query_processing(D, q, all_terms, k=None)
    print(f"Requête: {q}")
    for score, doc_idx in results:
        print(f"  Doc {doc_idx+1}: score={score:.3f} - {all_docs[doc_idx]}")
    print()

print("\n=== Avec réduction de rang (k=2) ===")
for q in queries:
    results = query_processing(D, q, all_terms, k=2)
    print(f"Requête: {q}")
    for score, doc_idx in results:
        print(f"  Doc {doc_idx+1}: score={score:.3f} - {all_docs[doc_idx]}")
    print()